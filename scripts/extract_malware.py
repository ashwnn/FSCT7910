#!/usr/bin/env python3
import csv
import glob
import os

SRC_GLOB = 'data/raw/Malware/*.csv'
RANSOM_PATH = 'data/Malware_Ransomware_2016_2025.csv'
BOTNET_PATH = 'data/Malware_Botnet_2016_2025.csv'

# Read existing incident_ids from targets to avoid duplicates
def read_existing_ids(path):
    ids = set()
    if not os.path.exists(path):
        return ids
    with open(path, newline='', encoding='utf-8') as f:
        # skip leading comment lines if any
        first = f.readline()
        if first.startswith('#'):
            # advance until header line (line that contains 'incident_id' heading)
            while not first.lower().strip().startswith('incident_id'):
                first = f.readline()
            header_line = first
            reader = csv.DictReader(f, fieldnames=[h.strip() for h in header_line.strip().split(',')])
        else:
            # first line is header
            header = first
            reader = csv.DictReader(f)
        # iterate rows
        for row in reader:
            # protect against blank lines
            if not row:
                continue
            iid = row.get('incident_id')
            if iid:
                ids.add(iid.strip())
    return ids

existing_ransom_ids = read_existing_ids(RANSOM_PATH)
existing_bot_ids = read_existing_ids(BOTNET_PATH)

# We'll collect rows to append, grouped by target
append_ransom = []
append_bot = []

def normalize_category(cat):
    if not cat:
        return ''
    return cat.strip().lower()

# Process each source file
for src in sorted(glob.glob(SRC_GLOB)):
    with open(src, 'r', encoding='utf-8') as f:
        # build a lines buffer skipping leading comment lines
        lines = []
        for line in f:
            if line.lstrip().startswith('#'):
                continue
            # include non-empty lines
            if line.strip() == '':
                continue
            lines.append(line)
        if not lines:
            continue
        # Use csv.DictReader on the buffered lines
        reader = csv.DictReader(lines)
        for row in reader:
            if not row:
                continue
            cat = normalize_category(row.get('category',''))
            iid = row.get('incident_id','').strip()
            if not iid:
                continue
            if 'ransom' in cat:
                if iid in existing_ransom_ids:
                    continue
                append_ransom.append(row)
                existing_ransom_ids.add(iid)
            elif 'botnet' in cat or 'bot' in cat:
                if iid in existing_bot_ids:
                    continue
                append_bot.append(row)
                existing_bot_ids.add(iid)

# Helper to write rows preserving header order of target file
def append_rows(path, rows):
    if not rows:
        return 0
    # Read header from target file if exists, else use keys from first row
    if os.path.exists(path):
        with open(path, newline='', encoding='utf-8') as f:
            first = f.readline()
            # find header line
            if first.startswith('#'):
                # seek header
                f.seek(0)
                header = None
                for l in f:
                    if l.lower().strip().startswith('incident_id'):
                        header = [h.strip() for h in l.strip().split(',')]
                        break
            else:
                header = [h.strip() for h in first.strip().split(',')]
    else:
        header = list(rows[0].keys())
    # Open for append
    with open(path, 'a', newline='', encoding='utf-8') as outf:
        writer = csv.DictWriter(outf, fieldnames=header)
        # If file is empty (just created), write header
        if os.path.getsize(path) == 0:
            writer.writeheader()
        for r in rows:
            # Ensure we only write fields present in header
            out = {k: r.get(k, '') for k in header}
            writer.writerow(out)
    return len(rows)

r_count = append_rows(RANSOM_PATH, append_ransom)
b_count = append_rows(BOTNET_PATH, append_bot)

print(f'Appended {r_count} ransomware rows to {RANSOM_PATH}')
print(f'Appended {b_count} botnet rows to {BOTNET_PATH}')

# Print small verification sample counts
print(f'Total ransomware incidents now: {len(existing_ransom_ids)}')
print(f'Total botnet incidents now: {len(existing_bot_ids)}')
